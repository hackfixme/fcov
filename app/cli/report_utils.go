package cli

import (
	"bufio"
	"fmt"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/mandelsoft/vfs/pkg/vfs"

	aerrors "go.hackfix.me/fcov/app/errors"
)

func createOutputFilterFromFile(file vfs.File) ([]string, error) {
	scanner := bufio.NewScanner(file)
	filter := []string{"*"} // exclude everything

	var (
		line, pkg string
		packages  = make(map[string]bool)
		files     []string
	)
	// First pass to split the packages being tested from files. Since we can't
	// reliably determine which .go file is tested, we include the entire package
	// in that case.
	for scanner.Scan() {
		line = scanner.Text()
		pkg = filepath.Dir(line)
		if strings.HasSuffix(line, "_test.go") {
			packages[pkg] = true
		} else if strings.HasSuffix(line, ".go") {
			files = append(files, line)
		}
	}

	// Second pass to assemble the filter
	for _, f := range files {
		pkg = filepath.Dir(f)
		if !packages[pkg] {
			filter = append(filter, fmt.Sprintf("!%s", f))
		}
	}

	for pkg := range packages {
		filter = append(filter, fmt.Sprintf("!%s/", pkg))
	}

	return filter, scanner.Err()
}

func findCoverageDirectories(fs vfs.FileSystem, root string) ([]string, error) {
	entries, err := vfs.ReadDir(fs, root)
	if err != nil {
		return nil, err
	}

	var covDirs []string

	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}

		dirPath := filepath.Join(root, entry.Name())
		files, err := vfs.ReadDir(fs, dirPath)
		if err != nil {
			return nil, err
		}

		hasCovMeta := false
		hasCovCounters := false

		for _, file := range files {
			name := file.Name()
			if strings.HasPrefix(name, "covmeta.") {
				hasCovMeta = true
			}
			if strings.HasPrefix(name, "covcounters.") {
				hasCovCounters = true
			}
			if hasCovMeta && hasCovCounters {
				absPath, err := filepath.Abs(dirPath)
				if err != nil {
					return nil, err
				}
				covDirs = append(covDirs, absPath)
				break
			}
		}
	}

	return covDirs, nil
}

// Generate legacy text coverage from directories containing binary coverage
// files generated by Go >=1.20.
// See https://dustinspecker.com/posts/go-combined-unit-integration-code-coverage/
// It returns paths to the generated text coverage files.
// In the future, fcov could work with the binary files directly, but for now we
// need to generate the legacy text format.
func generateTextCoverage(dirs []string) (covFiles []string, err error) {
	var output []byte
	for _, absPath := range dirs {
		outDir := filepath.Dir(absPath)
		dirName := filepath.Base(absPath)
		outFile := filepath.Join(outDir, dirName+".txt")

		cmd := exec.Command("go", "tool", "covdata", "textfmt",
			"-i="+absPath,
			"-o="+outFile)

		if output, err = cmd.CombinedOutput(); err != nil {
			return nil, aerrors.NewRuntimeError(
				fmt.Sprintf("failed to generate text coverage for %s", absPath), err, string(output))
		}

		covFiles = append(covFiles, outFile)
	}

	return covFiles, nil
}
